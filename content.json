{"pages":[{"title":"abc","text":"","link":"/abc/index.html"}],"posts":[{"title":"Maven相关","text":"Ubuntu的maven默认配置文件/etc/maven/settings.xml 加入 alimaven aliyun maven http://maven.aliyun.com/nexus/content/repositories/central/ central","link":"/2019/11/27/Maven%E7%9B%B8%E5%85%B3/"},{"title":"PSS的编译","text":"1、 fatal error: curl/curl.h: 没有那个文件或目录sudo apt install libcurl4-openssl-dev 2、如果在linux下使用epoll模型的话请配置/etc/security/limits.conf文件。在里面添加 soft noproc 10000 hard noproc 10000 soft nofile 10000 hard nofile 10000 错误：ACE_Dev_Poll_Reactor::open failed inside ACE_Dev_Poll_Reactor::CTOR:这个是linux的一些限制，可以配置新的值。EPOLL能处理的最大描述符数受用户可打开的最大描述符数限制，一般默认1024，可用ulimit -a查看， 修改方法两个： 1.ulimit -n 5120 #每次登录到shell都要修改，只对本次登录有效。 2.用ROOT用户修改/etc/security/limits.conf，添加以下两行，然后重新登录即可。修配配置文件后全局有效。 soft nofile 5120 hard nofile 10240","link":"/2019/11/22/PSS%E7%9A%84%E7%BC%96%E8%AF%91/"},{"title":"Protobuf的安装","text":"1、 *sudo apt-get install autoconf automake libtool curl make g++ unzip*git clone https://github.com/google/protobuf.git*cd protobuf*git submodule update –init –recursive*./autogen.sh*./configure*make*make check*sudo make install*sudo ldconfig # refresh shared library cache. 编译参数可能要加上：./configure CFLAGS=”-fPIC” CXXFLAGS=”-fPIC” 2、protoc –version 3\\编译protoc –cpp_out=. IMChat.proto","link":"/2019/11/22/Protobuf%E7%9A%84%E5%AE%89%E8%A3%85/"},{"title":"ThingsBoard 文档","text":"1、目录结构application: 应用程序主目录，整体项目打包时也是这个Module src/main/java/org.thingsboard.server: app主目录 actors: actor执行者目录 config: 配置类目录 controller: 控制器 exception: 异常处理 service: 服务目录，app打包后，server要运行的服务的实现都在这里 cluster: 集群服务，包括服务发现、服务实例等 script: 脚本执行服务，主要是规则引擎的执行（JS） transport: 消息传输服务 rpc: 远程调用服务 utils: 工具类common: 公共工具集、方法集模块 dao-api: 数据访问对象的服务接口，在这里做定义 data: 用于不同数据库之间的中间数据结构 message: 消息服务的实现集，包括集群消息、TB的基础服务消息、系统类消息 queue: 队列服务的实现集，用的Kafka transport: 消息传输通道服务的实现，定义公共接口，给客户端的transport层使用 coap: CoAP消息传输的实现，包括适配器和客户端 http: HTTP消息传输的实现 mqtt: MQTT消息传输的实现，包括适配器、会话、SSL工具等 util: 工具集（当前仅有一个异步回调工具）dao: 数据访问对象集合，整个应用的DAO层，一般只要dao的都要data，以实现不同数据库数据结构兼容。docker: 集群部署-docker容器解决方案，包含了部署环境和shell脚本 haproxy: HAproxy工具的配置文件存放处 tb-node: 应用程序节点配置存放目录 tb-transports: 消息传输服务的配置文件，包括coap,http,mqttimg: 应用图标存放处k8s: 容器编排工具Kubernetes的配置文件和自动化脚本msa: 微服务半自动构建模块，包含了黑盒测试、js执行引擎等 black-box-tests: 黑盒测试工具 js-excutor: js执行引擎，基于nodejs，用于执行规则引擎中的js代码（沙盒执行） tb: tb主应用程序配置 tb-node: tb程序节点配置 transport: docker中的消息传输服务的部署配置 web-ui: TB的Web用户界面在docker中部署的配置,自带http servernetty-mqtt: TB的MQTT协议的实现，包括连接、发布、订阅、遗嘱、关闭等rule-engine: TB的规则引擎，TB没有用开源的Drools等工具，而是自己开发了一套规则引擎，主要包含3个组件和1套服务接口 rule-engine-api: 服务接口的实现 rule-engine-components: 规则引擎组件，包含滤波器、动作、数据、脚本、延迟加载、消息、队列、RPC实现、邮件等tools: 工具模块，主要实现了MQTT with SSL客户端和REST客户端。可以测试用。transport: 三种消息传输服务启动器，服务的实现参考common/transport,mqtt协议的实现见netty-mqttui: TB的用户界面，主要使用AngularJS和react组件，单页应用（要替换掉，用Vue）————————————————版权声明：本文为CSDN博主「Echo侯」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/houpanqi/article/details/102742429","link":"/2019/12/27/ThingsBoard-%E6%96%87%E6%A1%A3/"},{"title":"Untitled","text":"uipp;ioiion","link":"/2020/05/28/Untitled/"},{"title":"hello","text":"下面介绍对特定项目设置用户名/邮箱/密码的方法 1.找到项目所在目录下的 .git，进入.git文件夹，然后执行如下命令分别设置用户名和邮箱git config user.name “Affandi” git config user.email “123333333@qq.com“ 然后执行命令查看config文件：cat config cat config 发现里面多了刚才配置的用户名和邮箱信息user，即成功为该项目单独设置了用户名和邮箱 …[branch “master”] remote = origin merge = refs/heads/master[user] name = Affandi email = 123333333@qq.com 2.如果git pull 每次都要求输入用户名和密码，则可以执行如下配置git config credential.helper store 执行后， cat config查看，则多了credential的内容： [user] name = Affandi email = 123333333@qq.com[credential] helper = store 然后再回到项目目录下执行git pull/push，根据提示输入用户名和密码，输入正确后，以后再执行git pull/push 就不用输入用户名和密码了 作者：Affandi链接：https://www.jianshu.com/p/bac094fb0222来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2019/11/20/hello/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/11/20/hello-world/"},{"title":"kafka groupid消费起始位置","text":"设置消费者properties的两个参数 consumer.group.id properties.setProperty(“auto.offset.reset”, “earliest”) // latest 注意： 只要不更改group.id，每次重新消费kafka，都是从上次消费结束的地方继续开始，不论”auto.offset.reset”属性设置的是什么 场景一：Kafka上在实时被灌入数据，但kafka上已经积累了两天的数据，如何从最新的offset开始消费？ （最新指相对于当前系统时间最新） 1.将group.id换成新的名字(相当于加入新的消费组) 2.网上文章写还要设置 properties.setProperty(“auto.offset.reset”, “latest”) 实验发现即使不设置这个，只要group.id是全新的，就会从最新的的offset开始消费 场景二：kafka在实时在灌入数据，kafka上已经积累了两天的数据，如何从两天前最开始的位置消费？ 1.将group.id换成新的名字 2.properties.setProperty(“auto.offset.reset”, “earliest”) 场景三：不更改group.id，只是添加了properties.setProperty(“auto.offset.reset”, “earliest”)，consumer会从两天前最开始的位置消费吗？ 不会，只要不更改消费组，只会从上次消费结束的地方继续消费 场景四：不更改group.id，只是添加了properties.setProperty(“auto.offset.reset”, “latest”)，consumer会从距离现在最近的位置消费吗？ 不会，只要不更改消费组，只会从上次消费结束的地方继续消费 应用： 正式打包上线前应该使用新的group.id，以便于从kafka最新的位置开始消费 只要将group.id换成全新的，不论”auto.offset.reset”是否设置，设置成什么，都会从最新的位置开始消费 以上都是我在实验中自己测试的，后来到网上找到一篇博客也在讲这个，盗用里面一张图 原文地址 https://blog.csdn.net/u011784767/article/details/78663168","link":"/2020/05/28/kafka-groupid%E6%B6%88%E8%B4%B9%E8%B5%B7%E5%A7%8B%E4%BD%8D%E7%BD%AE/"},{"title":"ubuntu上 grafana + influxdb + telegraf 安装配置","text":"Grafana 一个纯粹的HTML/JS应用，其功能非常强大，访问InfluxDB时不会有跨域访问的限制。只要配置好数据源为InfluxDB之后就可以，剩下的工作就是配置图表。 InfluxDB 开源的分布式时序、时间和指标数据库，使用Go语言编写，无需外部依赖。其中，时间序列数据库是数据格式里包含Timestamp字段的数据，比如某一时间用户上网流量、通话详单等。但是，有什么数据不包含Timestamp呢？几乎所有的数据都可以打上一个Timestamp字段。时间序列数据更重要的一个属性是如何去查询它，包括数据的过滤、计算等。 它有三大特性：时序性（Time Series）：与时间相关的函数的灵活使用（例如最大、最小、求和等）；度量（Metrics）：对实时大量数据进行计算；事件（Event）：支持任意的事件数据，换句话说，任意事件的数据我们都可以做操作。 Telegraf Telegraf是一款Go语言编写的metrics收集、处理、聚合的代理其设计目标是较小的内存使用，通过插件来构建各种服务和第三方组件的metrics收集Telegraf由4个独立的插件驱动 Input Plugins输入插件，收集系统、服务、第三方组件的数据Processor Plugins处理插件，转换、处理、过滤数据Aggregator Plugins聚合插件，数据特征聚合Output Plugins输出插件，写metrics数据 Grafana 负责 UI 界面的展示 telegraf 做数据的收集，比如服务器集群的性能监控 InfluxDb 是现在流行的时间序列数据库下面进入安装配置 我是在ubuntu 18.04上安装配置的下面是安装过程： INFLUXDB下载安装并启动 wget https://dl.influxdata.com/influxdb/releases/influxdb_1.7.9_amd64.debsudo dpkg -i influxdb_1.5.4_amd64.deb只有刚安装完要自行开启服务，以后开机就会自动带起服务了。 sudo service influxdb start 1连线测试 influx 1show databases create database mydb create database yourdb show databases 1 2 3 4 5 6 7移除influxDB sudo apt-get remove influxdb 1Start service sudo service influxdb start stop service sudo service influxdb stop restart service sudo service influxdb restart Step2 设定Influxdb 的设定档位置 #open with vimsudo vim /etc/influxdb/influxdb.conf #open with nanosudo nano /etc/influxdb/influxdb.conf 1 2 3 4 5资料库的储存路径 [meta] Where the metadata/raft database is stored dir = “/var/lib/influxdb/meta” [data] The directory where the TSM storage engine stores TSM files. dir = “/var/lib/influxdb/data” The directory where the TSM storage engine stores WAL files. wal-dir = “/var/lib/influxdb/wal” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15安全性管理(option) Determines whether HTTP endpoint is enabled. enabled = true The bind address used by the HTTP service. bind-address = “:8086” Determines whether user authentication is enabled over HTTP/HTTPS. auth-enabled = false step3 安全性管理3.1 建立帐号 3.1.1 建立管理者帐号 CREATE USER WITH PASSWORD ‘‘ WITH ALL PRIVILEGES exampleCREATE USER admin WITH PASSWORD ‘admin’ WITH ALL PRIVILEGES 3.1.2建立一般帐号 CREATE USER WITH PASSWORD ‘‘ example:CREATE USER usr WITH PASSWORD ‘1234’ 3.1.3 帐号一览 SHOW USERS 3.1.4帐号权限设定 授权全部的资料库(等于管理者帐号) GRANT ALL PRIVILEGES TO example:GRANT ALL PRIVILEGES TO usr 全部除权 REVOKE ALL PRIVILEGES FROM example:REVOKE ALL PRIVILEGES FROM usr 指定授权某资料库 GRANT [READ,WRITE,ALL] ON TO example:GRANT ALL ON mydb TO usr 指定除权某资料库 REVOKE [READ,WRITE,ALL] ON TO example:REVOKE ALL ON mydb TO usr 3.2 产生认证档( 自我认证) sudo openssl req -x509 -nodes -newkey rsa:2048 -keyout /etc/ssl/influxdb-selfsigned.key -out /etc/ssl/influxdb-selfsigned.crt -days #example:(建立十年的有效期)sudo openssl req -x509 -nodes -newkey rsa:2048 -keyout /etc/ssl/influxdb-selfsigned.key -out /etc/ssl/influxdb-selfsigned.crt -days 3650 #照程序接下來會要求寫一些基本資料#懶得寫的話就一路ENTER到底吧 3.3 修改设定档 #Determines whether HTTP endpoint is enabled. enabled = true #The bind address used by the HTTP service. bind-address = “:8086” #Determines whether user authentication is enabled over HTTP/HTTPS. auth-enabled = true #The SSL certificate to use when HTTPS is enabled. https-certificate = “/etc/ssl/influxdb-selfsigned.crt” #Use a separate private key location. https-private-key = “/etc/ssl/influxdb-selfsigned.key” 3.4 最后记得要重启服务 sudo service influxdb restart Step4 连线测试4.1 加密连线 #使用管理員權限登入(admin-擁有所有db的權限)influx -host ‘localhost’ -port ‘8086’ -ssl -unsafeSsl -username ‘admin’ -password ‘admin’ #使用一般帳號登入(usr-只有mydb的權限)influx -host ‘localhost’ -port ‘8086’ -ssl -unsafeSsl -username ‘usr’ -password ‘1234’ 4.2帐号权限测试使用这两个帐号测试以下指令看看 –有權限才能看到資料 show databases 通过 influxd config 查看当前配置 通过influxd run启动服务器启动客户端，测试一些基本的命令 与MySQL类似，一些常见的命令更多可参考链接： https://docs.influxdata.com/influxdb/v1.2/tools/shell/ telegraf 安装 add keycurl -sL https://repos.influxdata.com/influxdb.key | sudo apt-key add - add sourcesecho “deb https://repos.influxdata.com/ubuntu trusty stable” | sudo tee /etc/apt/sources.list.d/influxdb.list安装并启动telegraf服务 sudo apt-get update &amp;&amp; sudo apt-get install telegraf sudo systemctl start telegraf配置Telegraf vi /etc/telegraf/telegraf.conf Telegraf 和ACTIVEMQ#Read metrics about system load &amp; uptime[[inputs.system]] ##Uncomment to remove deprecated metrics. #fielddrop = [“uptime_format”] ##Gather ActiveMQ metrics[[inputs.activemq]]###ActiveMQ WebConsole URLurl = “http://127.0.0.1:8161&quot;###Required ActiveMQ Endpoint###deprecated in 1.11; use the url optionserver = “127.0.0.1”port = 61616 ###Credentials for basic HTTP authenticationusername = “admin”password = “admin”###Required ActiveMQ webadmin root pathwebadmin = “admin”###Maximum time to receive response.response_timeout = “5s”其中里面的账号密码都是WEB端的。 Telegraf 通过地址 http://127.0.0.1:8161/admin/xml/queues.jsp不断的获取数据统计信息 通过 http://127.0.0.1:8086/write?db=telegraf推送给InfluxDB","link":"/2019/11/23/ubuntu%E4%B8%8A-grafana-influxdb-telegraf-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"title":"ubuntu 常见命令","text":"1、find ./* -name ‘.‘ | xargs grep ‘username’内容查找 2、查看端口开放的情况sudo apt install net-toolsnetstat -aptn 3、update-alternatives –config java 4、正文回到顶部 前言 本教程将会演示如何设置Ubuntu16.04 Server版和Ubuntu18.04 Server版系统的静态固定IP地址。回到顶部2. 确认你要修改的网卡号 先确认你要修改的网卡号，假设你的服务器有多张网卡：1 ubuntu1804:~$ ip addr 我的服务器配置如下： 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00inet 127.0.0.1/8 scope host lovalid_lft forever preferred_lft foreverinet6 ::1/128 scope hostvalid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000link/ether 00:0c:29:f1:b5:e1 brd ff:ff:ff:ff:ff:ffinet 172.16.87.140/24 brd 172.16.87.255 scope global dynamic ens33valid_lft 1500sec preferred_lft 1500secinet6 fe80::20c:29ff:fef1:b5e1/64 scope linkvalid_lft forever preferred_lft forever 默认的网卡配置文件 默认情况下，网络使用DHCP ubuntu1804:~$ cat /etc/netplan/50-cloud-init.yaml配置文件内容如下 network: ethernets: ens33: dhcp4: yes addresses: [] version: 2 设置静态IP 需要把配置文件修改为以下内容：1 ubuntu1804:~$ sudo vi /etc/netplan/50-cloud-init.yaml 假设IP地址修改为192.168.1.100，子网掩码24位即255.255.255.0，网关设置为192.168.1.1，DNS1：223.5.5.5，DNS2：223.6.6.6 network: ethernets: ens33: dhcp4: no addresses: [192.168.1.100/24] optional: true gateway4: 192.168.1.1 nameservers: addresses: [223.5.5.5,223.6.6.6] version: 2 5. 应用新配置 ubuntu1804:~$ sudo netplan apply 使用ip addr检查新地址ubuntu1804:~$ ip addr 测试网络连通性ubuntu1804:~$ ping 192.168.1.100","link":"/2019/11/23/ubuntu-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"},{"title":"ubuntu远程桌面连接windows系统","text":"ubuntu端： sudo apt-get install rdesktop windows端： 需要允许此windows远程访问。 我的windows是windows server2012，基本操作：计算机—属性—远程设置—远程， 勾选：允许远程连接到此计算机。去掉默认勾选：仅允许运行使用网络级别验证…，（如果不取消这个，在运行时会出现“ERROR: recv: 连接被对端重置”）。 开始从ubuntu启动了，仅需要一条命令： rdesktop -f -a 16 192.168.1.112 就ok了。 用法： rdesktop[options] server[:port] 命令参数常用的有： -u用户名 -p密码 -n客户端主机名（显示windows任务管理器中的连接客户端名） -g桌面大小（ 宽＊ 高）[也可以用 x(小写的X)] -f全屏模式,从全屏模式切换出来按Ctrl+Alt+Enter -a连接颜色深度（最高到16位），一般选16才会显示真彩色（window7支持32位） -0数字0表示连接上windows控制台，等效mstsc/console命令 例子： 1、在全屏模式下用真彩色、客户端名为connection、用户名pan连接192.168.0.100控制台 $rdesktop-f -a 16 -n connection -u pan -0 192.168.0.100 2、以800*600（W＊H）窗口大小、真彩色、用户名pan、打开远程端口为16453的192.168.0.101控制台 $rdesktop -g 800*600 -a 16 -u pan -0 192.168.0.101:16453","link":"/2019/11/26/ubuntu%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5windows%E7%B3%BB%E7%BB%9F/"},{"title":"服务器配置过程","text":"1、安装JAVA sudo apt install openjdk-8-jdkJAVA11版本下，storm的虚拟机会报错","link":"/2019/11/29/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"},{"title":"activeMq-CPP","text":"一、avtiveMq服务端的安装1、从官网获取软件包： 网址：http://activemq.apache.org/activemq-590-release.html 2、解压运行activeMq wget http://archive.apache.org/dist/activemq/apache-activemq/5.9.0/apache-activemq-5.9.0-bin.tar.gz 解压：tar zxvf apache-activemq-5.9.0-bin.tar.gz 进入到解压的文件中去：运行activeMq 用ps -elf|grep active查看一下是否在后台运行 3、监控 ActiveMQ默认启动时，启动了内置的jetty服务器，提供一个用于监控ActiveMQ的admin应用。 访问链接形式：http://127.0.0.1:8161/admin/ 在浏览器中访问上面的链接（注意：ip修改成activeMq服务端的ip地址），出现登录界面，输入用户名和密码会进入activeMq管理网页页面（用户和密码都是admin） 在稍后的运行demo后可以从这个网页监控端查看队列名称、生产的消息数目以及消费情况以及是否有消费者正在等待消息的到来 二、activeMq cpp的编译安装1、介绍：AvtiveMqcpp是activeMq的c++接口，从官网提供地址下载即可 wget http://apache.fayea.com/activemq/activemq-cpp/3.9.3/activemq-cpp-library-3.9.3-src.tar.gz tar -zxvf activemq-cpp-library-3.9.3-src.tar.gz 先完成下面的步骤再来编译安装2、安装编译activeMqcpp需要安装其他的依赖包：2.1、安装依赖包CppUnit 获取源码包：wget https://sourceforge.net/projects/cppunit/files/cppunit/1.12.1/cppunit-1.12.1.tar.gz 解压：tar -zxvfcppunit-1.12.1.tar.gz 进入到解压的文件中，然后三步安装法 ./configure –prefix=/usr/local/cppunit/ LDFLAGS=’-ldl’ make makeinstall2.2、安装依赖包apr、apr-util和apr-iconv（如果你没有安装openssl的话需要安装openssl） 从http://apache.fayea.com/apr/镜像网站下载 Openssl网址：http://www.openssl.org/source/openssl-1.0.0a.tar.gz 同2.1步骤中一样先解压再进入到各自的解压的文件中去再执行下面的安装步骤（三个依次上面的额顺序安装） ./configure –prefix=/usr/local/apr/ make makeinstall ./configure –prefix=/usr/local/aprutil –with-apr=/usr/local/apr/ make makeinstall ./configure –prefix=/usr/local/apr-iconv/ –with-apr=/usr/local/apr/ make makeinstall ./config –prefix=/usr/local/openssl/ make makeinstall 2.3、再来编译activeMq cpp源码，执行下面的步骤即可 ./configure –prefix=/usr/local/ActiveMQ-CPP –with-apr=/usr/local/apr/ –with-apr-util=/usr/local/aprutil/ –with-cppunit=/usr/local/cppunit –with-openssl=/usr/local/openssl make make install 注：完成上面所有的步子就可以用cpp来编写activeMq应用接口了（producer和consumer） 注意： 出现这个或者fatal error: openssl/名单.h: No such file or directory。都是没有安装libssl-dev～ libssl-dev包含libraries, header files and manpages，他是openssl的一部分，而openssl对ssl进行了实现～ yum install libssl-dev yum install openssl* 然后重新编译即可三、运行demog++ producer.cpp -o send -I/usr/local/ActiveMQ-CPP/ -I/usr/local/apr/include/apr-1 -L/usr/local/ActiveMQ-CPP/lib -lactivemq-cppg++ consumer.cpp -o consumer -I/usr/local/ActiveMQ-CPP/ -I/usr/local/apr/include/apr-1 -L/usr/local/ActiveMQ-CPP/lib -lactivemq-cpp 1、send消息 2、消费消息 3、查看网页监控端的情况 代码如下：producer.cpp和consumer.cpp #include &lt;decaf/lang/Thread.h&gt; #include &lt;decaf/lang/Runnable.h&gt; #include &lt;decaf/util/concurrent/CountDownLatch.h&gt; #include &lt;decaf/lang/Long.h&gt; #include &lt;decaf/util/Date.h&gt; #include &lt;activemq/core/ActiveMQConnectionFactory.h&gt; #include &lt;activemq/util/Config.h&gt; #include &lt;activemq/library/ActiveMQCPP.h&gt; #include &lt;cms/Connection.h&gt; #include &lt;cms/Session.h&gt; #include &lt;cms/TextMessage.h&gt; #include &lt;cms/BytesMessage.h&gt; #include &lt;cms/MapMessage.h&gt; #include &lt;cms/ExceptionListener.h&gt; #include &lt;cms/MessageListener.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;iostream&gt; #include &lt;memory&gt; using namespace activemq; using namespace activemq::core; using namespace decaf; using namespace decaf::lang; using namespace decaf::util; using namespace decaf::util::concurrent; using namespace cms; using namespace std; //////////////////////////////////////////////////////////////////////////////// class SimpleProducer : public Runnable { private: Connection* connection; Session* session; Destination* destination; MessageProducer* producer; bool useTopic; bool clientAck; unsigned int numMessages; std::string brokerURI; std::string destURI; private: SimpleProducer( const SimpleProducer&amp; ); SimpleProducer&amp; operator= ( const SimpleProducer&amp; ); public: SimpleProducer( const std::string&amp; brokerURI, unsigned int numMessages, const std::string&amp; destURI, bool useTopic = false, bool clientAck = false ) : connection(NULL), session(NULL), destination(NULL), producer(NULL), useTopic(useTopic), clientAck(clientAck), numMessages(numMessages), brokerURI(brokerURI), destURI(destURI) { } virtual ~SimpleProducer(){ cleanup(); } void close() { this-&gt;cleanup(); } virtual void run() { try { auto_ptr&lt;ActiveMQConnectionFactory&gt; connectionFactory(new ActiveMQConnectionFactory( brokerURI ) ); try{ connection = connectionFactory-&gt;createConnection(); connection-&gt;start(); } catch( CMSException&amp; e ) { e.printStackTrace(); throw e; } if( clientAck ) { session = connection-&gt;createSession( Session::CLIENT_ACKNOWLEDGE ); } else { session = connection-&gt;createSession( Session::AUTO_ACKNOWLEDGE ); } if( useTopic ) { destination = session-&gt;createTopic( destURI ); } else { destination = session-&gt;createQueue( destURI ); } producer = session-&gt;createProducer( destination ); producer-&gt;setDeliveryMode( DeliveryMode::NON_PERSISTENT ); string threadIdStr = Long::toString( Thread::currentThread()-&gt;getId() ); string text = (string)&quot;Hello world! from thread &quot; + threadIdStr; for( unsigned int ix=0; ix&lt;numMessages; ++ix ) { TextMessage* message = session-&gt;createTextMessage( text ); message-&gt;setIntProperty( &quot;Integer&quot;, ix ); printf( &quot;Sent message #%d from thread %s\\n&quot;, ix+1, threadIdStr.c_str() ); producer-&gt;send( message ); delete message; } }catch ( CMSException&amp; e ) { e.printStackTrace(); } } private: void cleanup(){ try{ if( destination != NULL ) delete destination; }catch ( CMSException&amp; e ) { e.printStackTrace(); } destination = NULL; try { if( producer != NULL ) delete producer; }catch ( CMSException&amp; e ) { e.printStackTrace(); } producer = NULL; try{ if( session != NULL ) session-&gt;close(); if( connection != NULL ) connection-&gt;close(); }catch ( CMSException&amp; e ) { e.printStackTrace(); } try{ if( session != NULL ) delete session; }catch ( CMSException&amp; e ) { e.printStackTrace(); } session = NULL; try{ if( connection != NULL ) delete connection; }catch ( CMSException&amp; e ) { e.printStackTrace(); } connection = NULL; } }; int main(int argc , char* argv[]) { activemq::library::ActiveMQCPP::initializeLibrary(); std::cout &lt;&lt; &quot;=====================================================\\n&quot;; std::cout &lt;&lt; &quot;Starting produce message:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;-----------------------------------------------------\\n&quot;; std::string brokerURI =&quot;failover://(tcp://127.0.0.1:61616)&quot;; unsigned int numMessages = 2000; std::string destURI = &quot;test.chen&quot;; bool useTopics = false; SimpleProducer producer( brokerURI, numMessages, destURI, useTopics ); producer.run(); producer.close(); std::cout &lt;&lt; &quot;-----------------------------------------------------\\n&quot;; std::cout &lt;&lt; &quot;Finished test&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;=====================================================\\n&quot;; activemq::library::ActiveMQCPP::shutdownLibrary(); }consumer.cpp #include &lt;decaf/lang/Thread.h&gt; #include &lt;decaf/lang/Runnable.h&gt; #include &lt;decaf/util/concurrent/CountDownLatch.h&gt; #include &lt;activemq/core/ActiveMQConnectionFactory.h&gt; #include &lt;activemq/core/ActiveMQConnection.h&gt; #include &lt;activemq/transport/DefaultTransportListener.h&gt; #include &lt;activemq/library/ActiveMQCPP.h&gt; #include &lt;decaf/lang/Integer.h&gt; #include &lt;activemq/util/Config.h&gt; #include &lt;decaf/util/Date.h&gt; #include &lt;cms/Connection.h&gt; #include &lt;cms/Session.h&gt; #include &lt;cms/TextMessage.h&gt; #include &lt;cms/BytesMessage.h&gt; #include &lt;cms/MapMessage.h&gt; #include &lt;cms/ExceptionListener.h&gt; #include &lt;cms/MessageListener.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;iostream&gt; using namespace activemq; using namespace activemq::core; using namespace activemq::transport; using namespace decaf::lang; using namespace decaf::util; using namespace decaf::util::concurrent; using namespace cms; using namespace std; //////////////////////////////////////////////////////////////////////////////// class SimpleAsyncConsumer : public ExceptionListener, public MessageListener, public DefaultTransportListener { private: Connection* connection; Session* session; Destination* destination; MessageConsumer* consumer; bool useTopic; std::string brokerURI; std::string destURI; bool clientAck; private: SimpleAsyncConsumer( const SimpleAsyncConsumer&amp; ); SimpleAsyncConsumer&amp; operator= ( const SimpleAsyncConsumer&amp; ); public: SimpleAsyncConsumer( const std::string&amp; brokerURI, const std::string&amp; destURI, bool useTopic = false, bool clientAck = false ) : connection(NULL), session(NULL), destination(NULL), consumer(NULL), useTopic(useTopic), brokerURI(brokerURI), destURI(destURI), clientAck(clientAck) { } virtual ~SimpleAsyncConsumer() { this-&gt;cleanup(); } void close() { this-&gt;cleanup(); } void runConsumer() { try { ActiveMQConnectionFactory* connectionFactory = new ActiveMQConnectionFactory( brokerURI ); connection = connectionFactory-&gt;createConnection(); delete connectionFactory; ActiveMQConnection* amqConnection = dynamic_cast&lt;ActiveMQConnection*&gt;( connection ); if( amqConnection != NULL ) { amqConnection-&gt;addTransportListener( this ); } connection-&gt;start(); connection-&gt;setExceptionListener(this); if( clientAck ) { session = connection-&gt;createSession( Session::CLIENT_ACKNOWLEDGE ); } else { session = connection-&gt;createSession( Session::AUTO_ACKNOWLEDGE ); } if( useTopic ) { destination = session-&gt;createTopic( destURI ); } else { destination = session-&gt;createQueue( destURI ); } consumer = session-&gt;createConsumer( destination ); consumer-&gt;setMessageListener( this ); } catch (CMSException&amp; e) { e.printStackTrace(); } } virtual void onMessage( const Message* message ) { static int count = 0; try { count++; const TextMessage* textMessage = dynamic_cast&lt; const TextMessage* &gt;( message ); string text = &quot;&quot;; if( textMessage != NULL ) { text = textMessage-&gt;getText(); } else { text = &quot;NOT A TEXTMESSAGE!&quot;; } if( clientAck ) { message-&gt;acknowledge(); } printf( &quot;Message #%d Received: %s\\n&quot;, count, text.c_str() ); } catch (CMSException&amp; e) { e.printStackTrace(); } } virtual void onException( const CMSException&amp; ex AMQCPP_UNUSED ) { printf(&quot;CMS Exception occurred. Shutting down client.\\n&quot;); exit(1); } virtual void transportInterrupted() { std::cout &lt;&lt; &quot;The Connection&apos;s Transport has been Interrupted.&quot; &lt;&lt; std::endl; } virtual void transportResumed() { std::cout &lt;&lt; &quot;The Connection&apos;s Transport has been Restored.&quot; &lt;&lt; std::endl; } private: void cleanup(){ try{ if( destination != NULL ) delete destination; }catch (CMSException&amp; e) {} destination = NULL; try{ if( consumer != NULL ) delete consumer; }catch (CMSException&amp; e) {} consumer = NULL; try{ if( session != NULL ) session-&gt;close(); if( connection != NULL ) connection-&gt;close(); }catch (CMSException&amp; e) {} try{ if( session != NULL ) delete session; }catch (CMSException&amp; e) {} session = NULL; try{ if( connection != NULL ) delete connection; }catch (CMSException&amp; e) {} connection = NULL; } }; int main(int argc, char* argv[]) { activemq::library::ActiveMQCPP::initializeLibrary(); std::cout &lt;&lt; &quot;=====================================================\\n&quot;; std::cout &lt;&lt; &quot;Starting the example:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;-----------------------------------------------------\\n&quot;; std::string brokerURI = &quot;failover:(tcp://127.0.0.1:61616)&quot;; std::string destURI = &quot;test.chen&quot;; bool useTopics = false; bool clientAck = false; SimpleAsyncConsumer consumer( brokerURI, destURI, useTopics, clientAck ); consumer.runConsumer(); std::cout &lt;&lt; &quot;Press &apos;q&apos; to quit&quot; &lt;&lt; std::endl; while( std::cin.get() != &apos;q&apos;) {} consumer.close(); std::cout &lt;&lt; &quot;-----------------------------------------------------\\n&quot;; std::cout &lt;&lt; &quot;Finished with the example.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;=====================================================\\n&quot;; activemq::library::ActiveMQCPP::shutdownLibrary(); }现在用cppunit，运行./configure,make报错，提示如下 g++ -g -O2 -o .libs/DllPlugInTester DllPlugInTester.o CommandLineParser.o -ldl ../../src/cppunit/.libs/libcppunit.so -lm ../../src/cppunit/.libs/libcppunit.so: undefined reference to `dlsym&apos; ../../src/cppunit/.libs/libcppunit.so: undefined reference to `dlopen&apos; ../../src/cppunit/.libs/libcppunit.so: undefined reference to `dlclose&apos; 找 文章 解决此问题，运行 ./configure LDFLAGS=&apos;-ldl&apos; make ubuntu下解决expat.h: No such file or directory的问题在安装了libexpat1-dev之后解决apt-get install libexpat1-dev","link":"/2019/11/23/activeMq-CPP/"}],"tags":[{"name":"pss","slug":"pss","link":"/tags/pss/"},{"name":"Kafka","slug":"Kafka","link":"/tags/Kafka/"}],"categories":[{"name":"Cloud","slug":"Cloud","link":"/categories/Cloud/"},{"name":"Kafka","slug":"Kafka","link":"/categories/Kafka/"}]}