{"pages":[{"title":"abc","text":"","link":"/abc/index.html"}],"posts":[{"title":"Maven相关","text":"Ubuntu的maven默认配置文件/etc/maven/settings.xml 加入 alimaven aliyun maven http://maven.aliyun.com/nexus/content/repositories/central/ central","link":"/2019/11/27/Maven%E7%9B%B8%E5%85%B3/"},{"title":"PSS的编译","text":"1、 fatal error: curl/curl.h: 没有那个文件或目录sudo apt install libcurl4-openssl-dev 2、如果在linux下使用epoll模型的话请配置/etc/security/limits.conf文件。在里面添加 soft noproc 10000 hard noproc 10000 soft nofile 10000 hard nofile 10000 错误：ACE_Dev_Poll_Reactor::open failed inside ACE_Dev_Poll_Reactor::CTOR:这个是linux的一些限制，可以配置新的值。EPOLL能处理的最大描述符数受用户可打开的最大描述符数限制，一般默认1024，可用ulimit -a查看， 修改方法两个： 1.ulimit -n 5120 #每次登录到shell都要修改，只对本次登录有效。 2.用ROOT用户修改/etc/security/limits.conf，添加以下两行，然后重新登录即可。修配配置文件后全局有效。 soft nofile 5120 hard nofile 10240","link":"/2019/11/22/PSS%E7%9A%84%E7%BC%96%E8%AF%91/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/11/20/hello-world/"},{"title":"Protobuf的安装","text":"1、 *sudo apt-get install autoconf automake libtool curl make g++ unzip*git clone https://github.com/google/protobuf.git*cd protobuf*git submodule update –init –recursive*./autogen.sh*./configure*make*make check*sudo make install*sudo ldconfig # refresh shared library cache. 编译参数可能要加上：./configure CFLAGS=”-fPIC” CXXFLAGS=”-fPIC” 2、protoc –version 3\\编译protoc –cpp_out=. IMChat.proto","link":"/2019/11/22/Protobuf%E7%9A%84%E5%AE%89%E8%A3%85/"},{"title":"hello","text":"下面介绍对特定项目设置用户名/邮箱/密码的方法 1.找到项目所在目录下的 .git，进入.git文件夹，然后执行如下命令分别设置用户名和邮箱git config user.name “Affandi” git config user.email “123333333@qq.com“ 然后执行命令查看config文件：cat config cat config 发现里面多了刚才配置的用户名和邮箱信息user，即成功为该项目单独设置了用户名和邮箱 …[branch “master”] remote = origin merge = refs/heads/master[user] name = Affandi email = 123333333@qq.com 2.如果git pull 每次都要求输入用户名和密码，则可以执行如下配置git config credential.helper store 执行后， cat config查看，则多了credential的内容： [user] name = Affandi email = 123333333@qq.com[credential] helper = store 然后再回到项目目录下执行git pull/push，根据提示输入用户名和密码，输入正确后，以后再执行git pull/push 就不用输入用户名和密码了 作者：Affandi链接：https://www.jianshu.com/p/bac094fb0222来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2019/11/20/hello/"},{"title":"ubuntu 常见命令","text":"1、find ./* -name ‘.‘ | xargs grep ‘username’内容查找 2、查看端口开放的情况sudo apt install net-toolsnetstat -aptn 3、update-alternatives –config java","link":"/2019/11/23/ubuntu-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"},{"title":"ubuntu上 grafana + influxdb + telegraf 安装配置","text":"Grafana 一个纯粹的HTML/JS应用，其功能非常强大，访问InfluxDB时不会有跨域访问的限制。只要配置好数据源为InfluxDB之后就可以，剩下的工作就是配置图表。 InfluxDB 开源的分布式时序、时间和指标数据库，使用Go语言编写，无需外部依赖。其中，时间序列数据库是数据格式里包含Timestamp字段的数据，比如某一时间用户上网流量、通话详单等。但是，有什么数据不包含Timestamp呢？几乎所有的数据都可以打上一个Timestamp字段。时间序列数据更重要的一个属性是如何去查询它，包括数据的过滤、计算等。 它有三大特性：时序性（Time Series）：与时间相关的函数的灵活使用（例如最大、最小、求和等）；度量（Metrics）：对实时大量数据进行计算；事件（Event）：支持任意的事件数据，换句话说，任意事件的数据我们都可以做操作。 Telegraf Telegraf是一款Go语言编写的metrics收集、处理、聚合的代理其设计目标是较小的内存使用，通过插件来构建各种服务和第三方组件的metrics收集Telegraf由4个独立的插件驱动 Input Plugins输入插件，收集系统、服务、第三方组件的数据Processor Plugins处理插件，转换、处理、过滤数据Aggregator Plugins聚合插件，数据特征聚合Output Plugins输出插件，写metrics数据 Grafana 负责 UI 界面的展示 telegraf 做数据的收集，比如服务器集群的性能监控 InfluxDb 是现在流行的时间序列数据库下面进入安装配置 我是在ubuntu 18.04上安装配置的下面是安装过程： INFLUXDB下载安装并启动 wget https://dl.influxdata.com/influxdb/releases/influxdb_1.7.9_amd64.debsudo dpkg -i influxdb_1.5.4_amd64.deb只有刚安装完要自行开启服务，以后开机就会自动带起服务了。 sudo service influxdb start 1连线测试 influx 1show databases create database mydb create database yourdb show databases 1 2 3 4 5 6 7移除influxDB sudo apt-get remove influxdb 1Start service sudo service influxdb start stop service sudo service influxdb stop restart service sudo service influxdb restart Step2 设定Influxdb 的设定档位置 #open with vimsudo vim /etc/influxdb/influxdb.conf #open with nanosudo nano /etc/influxdb/influxdb.conf 1 2 3 4 5资料库的储存路径 [meta] Where the metadata/raft database is stored dir = “/var/lib/influxdb/meta” [data] The directory where the TSM storage engine stores TSM files. dir = “/var/lib/influxdb/data” The directory where the TSM storage engine stores WAL files. wal-dir = “/var/lib/influxdb/wal” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15安全性管理(option) Determines whether HTTP endpoint is enabled. enabled = true The bind address used by the HTTP service. bind-address = “:8086” Determines whether user authentication is enabled over HTTP/HTTPS. auth-enabled = false step3 安全性管理3.1 建立帐号 3.1.1 建立管理者帐号 CREATE USER WITH PASSWORD ‘‘ WITH ALL PRIVILEGES exampleCREATE USER admin WITH PASSWORD ‘admin’ WITH ALL PRIVILEGES 3.1.2建立一般帐号 CREATE USER WITH PASSWORD ‘‘ example:CREATE USER usr WITH PASSWORD ‘1234’ 3.1.3 帐号一览 SHOW USERS 3.1.4帐号权限设定 授权全部的资料库(等于管理者帐号) GRANT ALL PRIVILEGES TO example:GRANT ALL PRIVILEGES TO usr 全部除权 REVOKE ALL PRIVILEGES FROM example:REVOKE ALL PRIVILEGES FROM usr 指定授权某资料库 GRANT [READ,WRITE,ALL] ON TO example:GRANT ALL ON mydb TO usr 指定除权某资料库 REVOKE [READ,WRITE,ALL] ON TO example:REVOKE ALL ON mydb TO usr 3.2 产生认证档( 自我认证) sudo openssl req -x509 -nodes -newkey rsa:2048 -keyout /etc/ssl/influxdb-selfsigned.key -out /etc/ssl/influxdb-selfsigned.crt -days #example:(建立十年的有效期)sudo openssl req -x509 -nodes -newkey rsa:2048 -keyout /etc/ssl/influxdb-selfsigned.key -out /etc/ssl/influxdb-selfsigned.crt -days 3650 #照程序接下來會要求寫一些基本資料#懶得寫的話就一路ENTER到底吧 3.3 修改设定档 #Determines whether HTTP endpoint is enabled. enabled = true #The bind address used by the HTTP service. bind-address = “:8086” #Determines whether user authentication is enabled over HTTP/HTTPS. auth-enabled = true #The SSL certificate to use when HTTPS is enabled. https-certificate = “/etc/ssl/influxdb-selfsigned.crt” #Use a separate private key location. https-private-key = “/etc/ssl/influxdb-selfsigned.key” 3.4 最后记得要重启服务 sudo service influxdb restart Step4 连线测试4.1 加密连线 #使用管理員權限登入(admin-擁有所有db的權限)influx -host ‘localhost’ -port ‘8086’ -ssl -unsafeSsl -username ‘admin’ -password ‘admin’ #使用一般帳號登入(usr-只有mydb的權限)influx -host ‘localhost’ -port ‘8086’ -ssl -unsafeSsl -username ‘usr’ -password ‘1234’ 4.2帐号权限测试使用这两个帐号测试以下指令看看 –有權限才能看到資料 show databases 通过 influxd config 查看当前配置 通过influxd run启动服务器启动客户端，测试一些基本的命令 与MySQL类似，一些常见的命令更多可参考链接： https://docs.influxdata.com/influxdb/v1.2/tools/shell/ telegraf 安装 add keycurl -sL https://repos.influxdata.com/influxdb.key | sudo apt-key add - add sourcesecho “deb https://repos.influxdata.com/ubuntu trusty stable” | sudo tee /etc/apt/sources.list.d/influxdb.list安装并启动telegraf服务 sudo apt-get update &amp;&amp; sudo apt-get install telegraf sudo systemctl start telegraf配置Telegraf vi /etc/telegraf/telegraf.conf Telegraf 和ACTIVEMQ#Read metrics about system load &amp; uptime[[inputs.system]] ##Uncomment to remove deprecated metrics. #fielddrop = [“uptime_format”] ##Gather ActiveMQ metrics[[inputs.activemq]]###ActiveMQ WebConsole URLurl = “http://127.0.0.1:8161&quot;###Required ActiveMQ Endpoint###deprecated in 1.11; use the url optionserver = “127.0.0.1”port = 61616 ###Credentials for basic HTTP authenticationusername = “admin”password = “admin”###Required ActiveMQ webadmin root pathwebadmin = “admin”###Maximum time to receive response.response_timeout = “5s”其中里面的账号密码都是WEB端的。 Telegraf 通过地址 http://127.0.0.1:8161/admin/xml/queues.jsp不断的获取数据统计信息 通过 http://127.0.0.1:8086/write?db=telegraf推送给InfluxDB","link":"/2019/11/23/ubuntu%E4%B8%8A-grafana-influxdb-telegraf-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"title":"ubuntu远程桌面连接windows系统","text":"ubuntu端： sudo apt-get install rdesktop windows端： 需要允许此windows远程访问。 我的windows是windows server2012，基本操作：计算机—属性—远程设置—远程， 勾选：允许远程连接到此计算机。去掉默认勾选：仅允许运行使用网络级别验证…，（如果不取消这个，在运行时会出现“ERROR: recv: 连接被对端重置”）。 开始从ubuntu启动了，仅需要一条命令： rdesktop -f -a 16 192.168.1.112 就ok了。 用法： rdesktop[options] server[:port] 命令参数常用的有： -u用户名 -p密码 -n客户端主机名（显示windows任务管理器中的连接客户端名） -g桌面大小（ 宽＊ 高）[也可以用 x(小写的X)] -f全屏模式,从全屏模式切换出来按Ctrl+Alt+Enter -a连接颜色深度（最高到16位），一般选16才会显示真彩色（window7支持32位） -0数字0表示连接上windows控制台，等效mstsc/console命令 例子： 1、在全屏模式下用真彩色、客户端名为connection、用户名pan连接192.168.0.100控制台 $rdesktop-f -a 16 -n connection -u pan -0 192.168.0.100 2、以800*600（W＊H）窗口大小、真彩色、用户名pan、打开远程端口为16453的192.168.0.101控制台 $rdesktop -g 800*600 -a 16 -u pan -0 192.168.0.101:16453","link":"/2019/11/26/ubuntu%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5windows%E7%B3%BB%E7%BB%9F/"},{"title":"activeMq-CPP","text":"一、avtiveMq服务端的安装1、从官网获取软件包： 网址：http://activemq.apache.org/activemq-590-release.html 2、解压运行activeMq wget http://archive.apache.org/dist/activemq/apache-activemq/5.9.0/apache-activemq-5.9.0-bin.tar.gz 解压：tar zxvf apache-activemq-5.9.0-bin.tar.gz 进入到解压的文件中去：运行activeMq 用ps -elf|grep active查看一下是否在后台运行 3、监控 ActiveMQ默认启动时，启动了内置的jetty服务器，提供一个用于监控ActiveMQ的admin应用。 访问链接形式：http://127.0.0.1:8161/admin/ 在浏览器中访问上面的链接（注意：ip修改成activeMq服务端的ip地址），出现登录界面，输入用户名和密码会进入activeMq管理网页页面（用户和密码都是admin） 在稍后的运行demo后可以从这个网页监控端查看队列名称、生产的消息数目以及消费情况以及是否有消费者正在等待消息的到来 二、activeMq cpp的编译安装1、介绍：AvtiveMqcpp是activeMq的c++接口，从官网提供地址下载即可 wget http://apache.fayea.com/activemq/activemq-cpp/3.9.3/activemq-cpp-library-3.9.3-src.tar.gz tar -zxvf activemq-cpp-library-3.9.3-src.tar.gz 先完成下面的步骤再来编译安装2、安装编译activeMqcpp需要安装其他的依赖包：2.1、安装依赖包CppUnit 获取源码包：wget https://sourceforge.net/projects/cppunit/files/cppunit/1.12.1/cppunit-1.12.1.tar.gz 解压：tar -zxvfcppunit-1.12.1.tar.gz 进入到解压的文件中，然后三步安装法 ./configure –prefix=/usr/local/cppunit/ LDFLAGS=’-ldl’ make makeinstall2.2、安装依赖包apr、apr-util和apr-iconv（如果你没有安装openssl的话需要安装openssl） 从http://apache.fayea.com/apr/镜像网站下载 Openssl网址：http://www.openssl.org/source/openssl-1.0.0a.tar.gz 同2.1步骤中一样先解压再进入到各自的解压的文件中去再执行下面的安装步骤（三个依次上面的额顺序安装） ./configure –prefix=/usr/local/apr/ make makeinstall ./configure –prefix=/usr/local/aprutil –with-apr=/usr/local/apr/ make makeinstall ./configure –prefix=/usr/local/apr-iconv/ –with-apr=/usr/local/apr/ make makeinstall ./config –prefix=/usr/local/openssl/ make makeinstall 2.3、再来编译activeMq cpp源码，执行下面的步骤即可 ./configure –prefix=/usr/local/ActiveMQ-CPP –with-apr=/usr/local/apr/ –with-apr-util=/usr/local/aprutil/ –with-cppunit=/usr/local/cppunit –with-openssl=/usr/local/openssl make make install 注：完成上面所有的步子就可以用cpp来编写activeMq应用接口了（producer和consumer） 注意： 出现这个或者fatal error: openssl/名单.h: No such file or directory。都是没有安装libssl-dev～ libssl-dev包含libraries, header files and manpages，他是openssl的一部分，而openssl对ssl进行了实现～ yum install libssl-dev yum install openssl* 然后重新编译即可三、运行demog++ producer.cpp -o send -I/usr/local/ActiveMQ-CPP/ -I/usr/local/apr/include/apr-1 -L/usr/local/ActiveMQ-CPP/lib -lactivemq-cppg++ consumer.cpp -o consumer -I/usr/local/ActiveMQ-CPP/ -I/usr/local/apr/include/apr-1 -L/usr/local/ActiveMQ-CPP/lib -lactivemq-cpp 1、send消息 2、消费消息 3、查看网页监控端的情况 代码如下：producer.cpp和consumer.cpp #include &lt;decaf/lang/Thread.h&gt; #include &lt;decaf/lang/Runnable.h&gt; #include &lt;decaf/util/concurrent/CountDownLatch.h&gt; #include &lt;decaf/lang/Long.h&gt; #include &lt;decaf/util/Date.h&gt; #include &lt;activemq/core/ActiveMQConnectionFactory.h&gt; #include &lt;activemq/util/Config.h&gt; #include &lt;activemq/library/ActiveMQCPP.h&gt; #include &lt;cms/Connection.h&gt; #include &lt;cms/Session.h&gt; #include &lt;cms/TextMessage.h&gt; #include &lt;cms/BytesMessage.h&gt; #include &lt;cms/MapMessage.h&gt; #include &lt;cms/ExceptionListener.h&gt; #include &lt;cms/MessageListener.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;iostream&gt; #include &lt;memory&gt; using namespace activemq; using namespace activemq::core; using namespace decaf; using namespace decaf::lang; using namespace decaf::util; using namespace decaf::util::concurrent; using namespace cms; using namespace std; //////////////////////////////////////////////////////////////////////////////// class SimpleProducer : public Runnable { private: Connection* connection; Session* session; Destination* destination; MessageProducer* producer; bool useTopic; bool clientAck; unsigned int numMessages; std::string brokerURI; std::string destURI; private: SimpleProducer( const SimpleProducer&amp; ); SimpleProducer&amp; operator= ( const SimpleProducer&amp; ); public: SimpleProducer( const std::string&amp; brokerURI, unsigned int numMessages, const std::string&amp; destURI, bool useTopic = false, bool clientAck = false ) : connection(NULL), session(NULL), destination(NULL), producer(NULL), useTopic(useTopic), clientAck(clientAck), numMessages(numMessages), brokerURI(brokerURI), destURI(destURI) { } virtual ~SimpleProducer(){ cleanup(); } void close() { this-&gt;cleanup(); } virtual void run() { try { auto_ptr&lt;ActiveMQConnectionFactory&gt; connectionFactory(new ActiveMQConnectionFactory( brokerURI ) ); try{ connection = connectionFactory-&gt;createConnection(); connection-&gt;start(); } catch( CMSException&amp; e ) { e.printStackTrace(); throw e; } if( clientAck ) { session = connection-&gt;createSession( Session::CLIENT_ACKNOWLEDGE ); } else { session = connection-&gt;createSession( Session::AUTO_ACKNOWLEDGE ); } if( useTopic ) { destination = session-&gt;createTopic( destURI ); } else { destination = session-&gt;createQueue( destURI ); } producer = session-&gt;createProducer( destination ); producer-&gt;setDeliveryMode( DeliveryMode::NON_PERSISTENT ); string threadIdStr = Long::toString( Thread::currentThread()-&gt;getId() ); string text = (string)&quot;Hello world! from thread &quot; + threadIdStr; for( unsigned int ix=0; ix&lt;numMessages; ++ix ) { TextMessage* message = session-&gt;createTextMessage( text ); message-&gt;setIntProperty( &quot;Integer&quot;, ix ); printf( &quot;Sent message #%d from thread %s\\n&quot;, ix+1, threadIdStr.c_str() ); producer-&gt;send( message ); delete message; } }catch ( CMSException&amp; e ) { e.printStackTrace(); } } private: void cleanup(){ try{ if( destination != NULL ) delete destination; }catch ( CMSException&amp; e ) { e.printStackTrace(); } destination = NULL; try { if( producer != NULL ) delete producer; }catch ( CMSException&amp; e ) { e.printStackTrace(); } producer = NULL; try{ if( session != NULL ) session-&gt;close(); if( connection != NULL ) connection-&gt;close(); }catch ( CMSException&amp; e ) { e.printStackTrace(); } try{ if( session != NULL ) delete session; }catch ( CMSException&amp; e ) { e.printStackTrace(); } session = NULL; try{ if( connection != NULL ) delete connection; }catch ( CMSException&amp; e ) { e.printStackTrace(); } connection = NULL; } }; int main(int argc , char* argv[]) { activemq::library::ActiveMQCPP::initializeLibrary(); std::cout &lt;&lt; &quot;=====================================================\\n&quot;; std::cout &lt;&lt; &quot;Starting produce message:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;-----------------------------------------------------\\n&quot;; std::string brokerURI =&quot;failover://(tcp://127.0.0.1:61616)&quot;; unsigned int numMessages = 2000; std::string destURI = &quot;test.chen&quot;; bool useTopics = false; SimpleProducer producer( brokerURI, numMessages, destURI, useTopics ); producer.run(); producer.close(); std::cout &lt;&lt; &quot;-----------------------------------------------------\\n&quot;; std::cout &lt;&lt; &quot;Finished test&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;=====================================================\\n&quot;; activemq::library::ActiveMQCPP::shutdownLibrary(); }consumer.cpp #include &lt;decaf/lang/Thread.h&gt; #include &lt;decaf/lang/Runnable.h&gt; #include &lt;decaf/util/concurrent/CountDownLatch.h&gt; #include &lt;activemq/core/ActiveMQConnectionFactory.h&gt; #include &lt;activemq/core/ActiveMQConnection.h&gt; #include &lt;activemq/transport/DefaultTransportListener.h&gt; #include &lt;activemq/library/ActiveMQCPP.h&gt; #include &lt;decaf/lang/Integer.h&gt; #include &lt;activemq/util/Config.h&gt; #include &lt;decaf/util/Date.h&gt; #include &lt;cms/Connection.h&gt; #include &lt;cms/Session.h&gt; #include &lt;cms/TextMessage.h&gt; #include &lt;cms/BytesMessage.h&gt; #include &lt;cms/MapMessage.h&gt; #include &lt;cms/ExceptionListener.h&gt; #include &lt;cms/MessageListener.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;iostream&gt; using namespace activemq; using namespace activemq::core; using namespace activemq::transport; using namespace decaf::lang; using namespace decaf::util; using namespace decaf::util::concurrent; using namespace cms; using namespace std; //////////////////////////////////////////////////////////////////////////////// class SimpleAsyncConsumer : public ExceptionListener, public MessageListener, public DefaultTransportListener { private: Connection* connection; Session* session; Destination* destination; MessageConsumer* consumer; bool useTopic; std::string brokerURI; std::string destURI; bool clientAck; private: SimpleAsyncConsumer( const SimpleAsyncConsumer&amp; ); SimpleAsyncConsumer&amp; operator= ( const SimpleAsyncConsumer&amp; ); public: SimpleAsyncConsumer( const std::string&amp; brokerURI, const std::string&amp; destURI, bool useTopic = false, bool clientAck = false ) : connection(NULL), session(NULL), destination(NULL), consumer(NULL), useTopic(useTopic), brokerURI(brokerURI), destURI(destURI), clientAck(clientAck) { } virtual ~SimpleAsyncConsumer() { this-&gt;cleanup(); } void close() { this-&gt;cleanup(); } void runConsumer() { try { ActiveMQConnectionFactory* connectionFactory = new ActiveMQConnectionFactory( brokerURI ); connection = connectionFactory-&gt;createConnection(); delete connectionFactory; ActiveMQConnection* amqConnection = dynamic_cast&lt;ActiveMQConnection*&gt;( connection ); if( amqConnection != NULL ) { amqConnection-&gt;addTransportListener( this ); } connection-&gt;start(); connection-&gt;setExceptionListener(this); if( clientAck ) { session = connection-&gt;createSession( Session::CLIENT_ACKNOWLEDGE ); } else { session = connection-&gt;createSession( Session::AUTO_ACKNOWLEDGE ); } if( useTopic ) { destination = session-&gt;createTopic( destURI ); } else { destination = session-&gt;createQueue( destURI ); } consumer = session-&gt;createConsumer( destination ); consumer-&gt;setMessageListener( this ); } catch (CMSException&amp; e) { e.printStackTrace(); } } virtual void onMessage( const Message* message ) { static int count = 0; try { count++; const TextMessage* textMessage = dynamic_cast&lt; const TextMessage* &gt;( message ); string text = &quot;&quot;; if( textMessage != NULL ) { text = textMessage-&gt;getText(); } else { text = &quot;NOT A TEXTMESSAGE!&quot;; } if( clientAck ) { message-&gt;acknowledge(); } printf( &quot;Message #%d Received: %s\\n&quot;, count, text.c_str() ); } catch (CMSException&amp; e) { e.printStackTrace(); } } virtual void onException( const CMSException&amp; ex AMQCPP_UNUSED ) { printf(&quot;CMS Exception occurred. Shutting down client.\\n&quot;); exit(1); } virtual void transportInterrupted() { std::cout &lt;&lt; &quot;The Connection&apos;s Transport has been Interrupted.&quot; &lt;&lt; std::endl; } virtual void transportResumed() { std::cout &lt;&lt; &quot;The Connection&apos;s Transport has been Restored.&quot; &lt;&lt; std::endl; } private: void cleanup(){ try{ if( destination != NULL ) delete destination; }catch (CMSException&amp; e) {} destination = NULL; try{ if( consumer != NULL ) delete consumer; }catch (CMSException&amp; e) {} consumer = NULL; try{ if( session != NULL ) session-&gt;close(); if( connection != NULL ) connection-&gt;close(); }catch (CMSException&amp; e) {} try{ if( session != NULL ) delete session; }catch (CMSException&amp; e) {} session = NULL; try{ if( connection != NULL ) delete connection; }catch (CMSException&amp; e) {} connection = NULL; } }; int main(int argc, char* argv[]) { activemq::library::ActiveMQCPP::initializeLibrary(); std::cout &lt;&lt; &quot;=====================================================\\n&quot;; std::cout &lt;&lt; &quot;Starting the example:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;-----------------------------------------------------\\n&quot;; std::string brokerURI = &quot;failover:(tcp://127.0.0.1:61616)&quot;; std::string destURI = &quot;test.chen&quot;; bool useTopics = false; bool clientAck = false; SimpleAsyncConsumer consumer( brokerURI, destURI, useTopics, clientAck ); consumer.runConsumer(); std::cout &lt;&lt; &quot;Press &apos;q&apos; to quit&quot; &lt;&lt; std::endl; while( std::cin.get() != &apos;q&apos;) {} consumer.close(); std::cout &lt;&lt; &quot;-----------------------------------------------------\\n&quot;; std::cout &lt;&lt; &quot;Finished with the example.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;=====================================================\\n&quot;; activemq::library::ActiveMQCPP::shutdownLibrary(); }现在用cppunit，运行./configure,make报错，提示如下 g++ -g -O2 -o .libs/DllPlugInTester DllPlugInTester.o CommandLineParser.o -ldl ../../src/cppunit/.libs/libcppunit.so -lm ../../src/cppunit/.libs/libcppunit.so: undefined reference to `dlsym&apos; ../../src/cppunit/.libs/libcppunit.so: undefined reference to `dlopen&apos; ../../src/cppunit/.libs/libcppunit.so: undefined reference to `dlclose&apos; 找 文章 解决此问题，运行 ./configure LDFLAGS=&apos;-ldl&apos; make ubuntu下解决expat.h: No such file or directory的问题在安装了libexpat1-dev之后解决apt-get install libexpat1-dev","link":"/2019/11/23/activeMq-CPP/"}],"tags":[{"name":"pss","slug":"pss","link":"/tags/pss/"}],"categories":[{"name":"Cloud","slug":"Cloud","link":"/categories/Cloud/"}]}